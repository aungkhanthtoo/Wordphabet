package com.ahadar.wordphabet

object ListsProvider {
    val WORDS: List<String> =
        mutableListOf(
            "accountant",
            "acquaintance",
            "action",
            "activity",
            "administration",
            "advertising",
            "agile",
            "agreement",
            "alcohol",
            "ancestor",
            "answer",
            "apparatus",
            "banish",
            "barrier",
            "behave",
            "birthday",
            "bomber",
            "bracket",
            "break down",
            "brilliance",
            "button",
            "cabin",
            "cable",
            "calculation",
            "capital",
            "carbon",
            "casualty",
            "catalogue",
            "decisive",
            "declaration",
            "define",
            "delay",
            "enfix",
            "enhance",
            "entertainment",
            "entitlement",
            "equal",
            "fairy",
            "fault",
            "favour",
            "feedback",
            "feign",
            "feminine",
            "galaxy",
            "garage",
            "garlic",
            "gesture",
            "glacier",
            "glance",
            "gossip",
            "gradient",
            "gradual",
            "grandmother",
            "grave",
            "gravity",
            "gregarious",
            "grief",
            "guarantee",
            "guitar",
            "hardship",
            "hardware",
            "haunt",
            "hunter",
            "imperial",
            "imposter",
            "impound",
            "impress",
            "infinite",
            "inflate",
            "inhibition",
            "jealous",
            "joystick",
            "jungle",
            "justice",
            "kidnap",
            "killer",
            "kitchen",
            "knock",
            "labour",
            "layout",
            "learn",
            "length",
            "letter",
            "liberal",
            "makeup",
            "management",
            "marketing",
            "meadow",
            "merchant",
            "migration",
            "ministry",
            "minority",
            "miracle",
            "national",
            "nationalism",
            "obese",
            "object",
            "offender",
            "onion",
            "overcharge",
            "paint",
            "paragraph",
            "qualify",
            "queen",
            "respect",
            "responsibility",
            "retire",
            "retired",
            "retirement",
            "revise",
            "revival",
            "reward",
            "ridge",
            "rotten",
            "scenario",
            "scene",
            "script",
            "sense",
            "sentiment",
            "service",
            "settlement",
            "sheet",
            "shine",
            "shiver",
            "short",
            "skate",
            "sleeve",
            "slippery",
            "slogan",
            "solution",
            "space",
            "spill",
            "spoil",
            "spring",
            "staircase",
            "stake",
            "sword",
            "talented",
            "teach",
            "tense",
            "tension",
            "thank",
            "thigh",
            "think",
            "thirsty",
            "unpleasant",
            "vacuum",
            "variation",
            "veteran",
            "virgin",
            "wagon",
            "wardrobe",
            "warning",
            "waste",
            "water",
            "weapon",
            "wear out",
            "wedding",
            "white",
            "wilderness",
            "winter",
            "withdraw",
            "work out",
            "wreck",
            "writer",
            "year",
            "yearn",
            "yesterday",
            "zorro",
            "_The End!"
        )

    fun buildMapWithIndexes(words: List<String> = WORDS) = words
        .mapIndexed { index, string -> index to string[0].toUpperCase().toString() }
        .distinctBy { it.second }
        .toMap()


    private const val RED = "#FF0000"
    private const val ORANGE = "#FF6600"
    private const val YELLOW = "#FFFF00"
    private const val GREEN = "#00FF00"
    private const val BLUE = "#0000FF"
    // 5 shades of colours is enough to prove the concept
    val COLOURS_LIST_HEX: List<String> =
        mutableListOf(
            RED,
            "#FF1A1A",
            "#FF3333",
            "#FF4D4D",
            "#FF6666",
            "#FF8080",
            "#FF9999",
            "#FFB3B3",

            ORANGE,
            "#FF751A",
            "#FF8533",
            "#FF944D",
            "#FFA366",
            "#FFB380",
            "#FFC299",
            "#FFD1B3",

            YELLOW,
            "#FFFF1A",
            "#FFFF33",
            "#FFFF4D",
            "#FFFF66",
            "#FFFF80",
            "#FFFF99",
            "#FFFFB3",

            GREEN,
            "#1AFF1A",
            "#33FF33",
            "#4DFF4D",
            "#66FF66",
            "#80FF80",
            "#99FF99",
            "#B3FFB3",

            BLUE,
            "#1A1AFF",
            "#3333FF",
            "#4D4DFF",
            "#6666FF",
            "#8080FF",
            "#9999FF",
            "#B3B3FF"

        )
    // Hardcoded way
    val HEADERS_COLOURS: Map<Int, Pair<String, String>> =
            mapOf(COLOURS_LIST_HEX.indexOf(RED) to Pair(::RED.name, RED),
                COLOURS_LIST_HEX.indexOf(ORANGE) to Pair(::ORANGE.name, ORANGE),
                COLOURS_LIST_HEX.indexOf(YELLOW) to Pair(::YELLOW.name, YELLOW),
                COLOURS_LIST_HEX.indexOf(GREEN) to Pair(::GREEN.name, GREEN),
                COLOURS_LIST_HEX.indexOf(BLUE) to Pair(::BLUE.name, BLUE)
            )
}
